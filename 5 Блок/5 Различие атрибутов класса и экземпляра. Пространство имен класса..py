class Human:
    head = True     # классовый атрибут. используют редко, он принадлежит к классу, он в его пространстве имён

    def __init__(self, name, age):           # __init__ - метод который работает 1 раз нужен для инцилизация класса
        self.name = name                # self -
        self.age = age                  # атрибуты, переменные внутри класса, при создание передаём значение
        self.say_info()                 # вызвали метод внутри класса
    def say_info(self):
        print(f'Привет, меня зовут {self.name}, мне {self.age}')                # Метод, собственная структура данных, собственный тип, с собственными характеристиками и способностями
    def birthday(self):
        self.age += 1
        print(f'У меня день рождения, мне теперь {self.age}')
    def __str__(self):
        return f'{self.name}'           # строковое представляет нашего класса при вызове print
    def __len__(self):
        return self.age
    def __lt__(self, other):
        return self.age < other.age                 # оператор для сравнения если меньше, перезрузили оператор сравнения в свой класс
#other - второй элемент сравнения
    def __gt__(self, other):
        return self.age > other.age                 # оператор для сравнения если больше, перезрузили оператор сравнения в свой класс
    def __eq__(self, other):
        return self.name == other.name and self.name == other.name      # оператор для сравнения если переменные равны, перезрузили оператор сравнения в свой класс

    def __bool__(self):
        return bool(self.age)       # True - если не равен 0
    def __del__(self):
        print(f'{self.name} ушёл')


den = Human('Denis', 22)
max_ = Human('Max', 22)
max_.name = 'Denis'
print(den < max_)
print(den > max_)
max_.birthday()
print(den < max_)
print(den > max_)
print(den == max_)
a = 5
print(den)
# Human.__dict__ - написать в дебаг чтобы увидеть простраство имён, во время выполнения программы

# класс — это наш собственный тип данных.
'''
Что нам даёт это знание? Давайте запустим этот же самый файл в интерактивном режиме и посмотрим. Если развернуть Human, то увидим, 
что у нашего класса есть 1 атрибут head(рис.4), но не атрибутов name и age. 
При этом, если заглянем в наши объекты, то увидим здесь name, age и head(рис.5). Получается у объектов есть атрибут класса, а у класса нет атрибутов этих объектов.

Представим это в виде схемы. У нас есть наш класс Human и внутри него есть определённый атрибут head со значением False(рис.10). Когда на основе этого класса создаются объекты, 
в нашем случае den и max, они наследуются от 1 класса Human. Однако у den и max есть name и age(рис.11). Если вспомнить то, как работают наши функции, когда разбирали локальные, 
глобальные переменные, то можем вспомнить, что сначала, когда мы обращаемся к чему-то, смотрим в пределах нашего локального пространства имён. 
Если внутри локального пространства имён у нас не находится соответствующего имени, то начинаем искать в другом месте, в пределах области видимости, в пределах того, куда можем забраться.

Здесь, когда мы пытаемся обратиться к den и достать оттуда атрибут head, будем получать то значение, которое находится внутри нашего класса, 
потому что у экземпляров класса есть доступ к атрибутам самого класса. Также будем получать это значение, находящееся внутри класса Human. 
Соответственно, при изменении значения в нашем классе, у нас это же значение будет меняться внутри каждого экземпляра(объекта), 
но фактически у нас этого значения нет ни у den, ни у max. Однако если сейчас возьмём, например, dеn, достанем у него атрибут head и изменим его на true(рис.12), то здесь, 
с точки зрения нашей памяти, у нас появилось у den значение True, а у Макса и у Human осталось False. Почему так произошло?

Для того чтобы понять это, давайте сейчас возьмём den и попробуем посмотреть на него как на словарь(рис.13). Получается,
что у нас этот атрибут head создался внутри нашего экземпляра(рис.14). Теперь при обращении к этому атрибуту, мы в первую очередь будем смотреть на атрибут, 
содержащийся внутри экземпляра, а не внутри класса.
 
Вот эти различия, важно понимать, важно просто осознавать, как это работает. Как правило, классовые атрибуты используются реже, тем не менее они имеют место быть,
потому что для большинства экземпляров все равно есть какие-то атрибуты, которые будут общими. В них будет необходимость при изменении, допустим, этого атрибута внутри класса, 
чтобы это значение передавалось ко всем экземплярам. То есть, если бы мы не создавали атрибут head внутри den, при изменении этого атрибута внутри класса, 
изменения бы проходили в каждом экземпляре. Когда нам нужна такая логика, необходимо пользоваться именно атрибутами класса, не атрибутами экземпляра. Это и есть 
особенность классовых атрибутов и атрибутов экземпляров. Напоминаем, что экземпляр — это тот объект, который создаётся на основе класса, то есть переменная, созданная на основе этого класса.
'''