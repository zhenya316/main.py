class Human:
    def __init__(self, name, age):           # __init__ - метод который работает 1 раз нужен для инцилизация класса
        self.name = name                # self -
        self.age = age                  # атрибуты, переменные внутри класса, при создание передаём значение
        self.say_info()                 # вызвали метод внутри класса
    def say_info(self):
        print(f'Привет, меня зовут {self.name}, мне {self.age}')                # Метод, собственная структура данных, собственный тип, с собственными характеристиками и способностями

    def birthday(self):
        self.age += 1
        print(f'У меня день рождения, мне теперь {self.age}')
    def __len__(self):
        return self.age

    def __del__(self):
        print(f'{self.name} ушёл')

den = Human('Denis', 22)
max_ = Human('Max', 22)
max_.birthday()
print(den.__len__())
input()

'''
На самом деле это очень частое явление, потому что это эффективно, здесь можно придерживаться объектно-ориентированного программирования. Оно содержит в себе или состоит из трёх принципов:
Наследование
Инкапсуляция
Полиморфизм
Все эти принципы позволяют нам реализовывать нашу программу эффективно:
какие-то позволяет нам создавать очень много классов описаний, но которые будут либо дополнять базовый класс, либо же как-то изменять его поведение, то есть делать наши классы более уникальными;
какие-то будут позволять пользователям взаимодействовать только с тем, что мы хотим, скрыв важные внутренние особенности с целью обезопасить работу.
'''
