print(int.__mro__)      # команда для вызова цепочки наследования, все встроенные классы наследуют от класа "object"
print(object)
'''
Давайте на него взглянем для этого в print(), выведем object(рис.2) и зажмём ctrl, можно даже не в print(), просто нам нужно имя, через которое можно перейти к его первоисточнику. 
Тут видим, что класс Object является базовым классом всей иерархии классов(рис.3), а внутри можно увидеть какие-то знакомые, какие-то нет методы, например, привычный нам init()(рис.4). 
На самом деле init(), срабатывает после того, 
как создается объект класса. Именно он позволяет нам присваивать какие-то уникальные характеристики для каждого объекта. А вот метод new() срабатывает перед созданием объекта класса.
'''

class User:
    def __new__(cls, *args, **kwargs):
        print('я в нью, привет')                # cls - указывает на класс, __new__ - возвращает ссылку на класс, переопределили его и теперь обьект не создался
        return super().__new__(cls)             # с методом super создали объект и init инцилизировал его
    def __init__(self):
        print('я в ините, привет')          # self - указывает на себя

    def __str__(self):
        return '1'


user1 = User()
user2 = User()
print(User.__mro__)
print(user1 is user2)       # сохраняются в разные места в памяти
print(id(user1), id(user2))




# Super() - это функция, которая позволяет вызывать методы родительского класса в дочернем классе.
# Она используется, когда нужно вызвать методы родительского класса в дочернем классе, чтобы избежать дублирования кода и улучшить его читаемость.





'''
В каких же случаях может пригодиться переопределение метода?
На самом деле ситуации бывают разные. Одна из популярных ситуаций — это, например, такой паттерн Singleton, когда нам нужно, чтобы в нашей программе объект класса создавался единожды, 
чтобы избежать повторной его инициализации.
Посмотрим реализацию Singleton в учебном варианте. Например, вы создаёте уникального пользователя. Нам нужно вернуть (return) ссылку на этот класс User. 
Чтобы это сделать воспользуемся методом Super() и вызовем метод new(), передав туда ссылку на класс (cls)(рис.10) и получится так, что из класса object готовый метод применим в нашем собственном.
На самом деле каждый объект перенимает вот эти методы, такие как init(), new() и ряд ещё остальных, которые там присутствуют, находящиеся внутри класса Object. По сути, 
он уже есть внутри нашего класса User.

Для того чтобы его переопределить создадим метод new() и выведем строку “Я в нью”. Обратите внимание, что метод new() принимает cls в качестве первого параметра, 
а не self. На предыдущих занятиях выяснили, 
что self является указателем на объект класса, а вот этот cls будет являться указателем на класс. Получается, сейчас мы переопределили метод new().
'''
class User1:
    __instance = None
    def __new__(cls, *args, **kwargs):
        print('я в нью, привет')
        if cls.__instance is None:
            cls.__instance = super().__new__(cls)
        return cls.__instance



user3 = User1()
user4 = User1()
print(id(user3), id(user4))     # сохраняются в одно место в памяти
print(user3 is user4)

'''
Рассмотрим реализацию Singleton. Создадим какой-нибудь классовый атрибут __instance = None и внутри метода new() добавим условие, что если вот этот атрибут __instance
внутри нашего класса = None, то есть ещё не был создан ни 1 объект этого класса, то в этот атрибут запишем ссылку на наш класс. Метод new() будет возвращать эту самую ссылку(рис.14). 
Таким образом видим, что при такой реализации, несмотря на то, что создаются новые объекты, они все ведут к одному адресу 
в памяти(рис.15). Если взять User1 и воспользоваться оператором is, то в этот раз получим результат True(рис.16). В будущем это вам может очень сильно пригодиться. Это и есть метод new().
'''


'''
Последнее, что рассмотрим, может пригодиться в работе с вашими классами — это переменное количество параметров внутри, например, того же init(). Допустим, вы пишите класс и не знаете, 
сколько параметров будет принимать объект этого класса. Ранее вы уже изучали функции и здесь принцип на самом деле похож.
Давайте подготовим небольшие тестовые данные. Пускай у нас будет other — это список, содержащий в себе будущие *args, и user для **kwargs, ключи и значения(рис.17). 
В init() напишем *args, **kwargs(рис.18).
'''

class User:
    __instance = None
    def __new__(cls, *args, **kwargs):
        print('я в нью, привет')
        if cls.__instance is None:
            cls.__instance = super().__new__(cls)
        return cls.__instance
    def __init__(self, *args, **kwargs):
        print('я в ините, привет')
        self.args = args
        for key, value in kwargs.items():       # для создания имён словаря, к которым можно обращаться по ключу
            setattr(self, key, value)
        #self.name = kwargs.get('name')
        #self.kwargs = kwargs


other = [1, 2, 3]
user = {'name': 'MAX', 'age': 25, 'name1': 'den'}

user1 = User(*other, **user)
print(user1.args)
#print(user1.kwargs)         # список и словарь передались в args, позиционная переменная передалась сюда, если не раскрыть их *, **,

#print(user1.name)
print(user1.name)
print(user1.age)
print(user1.name1)


